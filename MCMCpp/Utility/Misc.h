/*!*****************************************************************************
********************************************************************************
**
** @copyright Copyright (C) 2017 James Till Matta
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
** 
********************************************************************************
*******************************************************************************/
#ifndef MCMCPP_UTILITY_MISC_H
#define MCMCPP_UTILITY_MISC_H
// includes for C system headers
#include<stdlib.h>//needed for aligned allocation, which appears in C11 but does not appear in C++ until C++17
// includes for C++ system headers
// includes from other libraries
// includes from MCMCpp

namespace MCMC
{

namespace Utility
{

static const unsigned int AlignmentLength = 64;///<Stores the memory boundary to force memory alignment to, 64 is sufficient for cache lines and up to the 256-bit AVX instructions, 128 will handle AVX-512 instructions as well

/*!
 * @brief Takes a size in bytes to allocate, increases it to be the nearest multiple of AlignmentLength then allocates it
 * @param allocSize The minimum size in bytes to allocate
 * @return the pointer to the allocated memory
 */
template<class ParamType>
ParamType* autoAlignedAlloc(size_t allocSize)
{
    if(allocSize%Utility::AlignmentLength) //if allocSize is not an integral multiple of AlignementLength
    {
        allocSize = (((allocSize/AlignmentLength)+1)*AlignmentLength);
    }
    return reinterpret_cast<ParamType*>(aligned_alloc(AlignmentLength, allocSize));
}

/*!
 * @brief Takes a pointer that was generated by autoAlignedAlloc and frees it in the appropriate way
 * @param ptr The pointer to the memory segment to be freed
 */
template<class ParamType>
void delAAA(ParamType* ptr)
{
    free(ptr);
}

}
}
#endif  //MCMCPP_UTILITY_MISC_H
