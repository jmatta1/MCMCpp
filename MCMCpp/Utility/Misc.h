/*!*****************************************************************************
********************************************************************************
**
** @copyright Copyright (C) 2017-2018 James Till Matta
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
** 
********************************************************************************
*******************************************************************************/
#ifndef MCMCPP_UTILITY_MISC_H
#define MCMCPP_UTILITY_MISC_H
// includes for C system headers
#include<stdlib.h>//needed for aligned allocation, which appears in C11 but does not appear in C++ until C++17
// includes for C++ system headers
// includes from other libraries
// includes from MCMCpp

namespace MCMC
{

namespace Utility
{

namespace Detail
{
/*!
 * \brief Internal function to find the greatest common divisor of two integers using the euclidean algorithm
 * \param a The first integer input (must be greater than or equal to b)
 * \param b The second integer input (must be less than or equal to a)
 * \return The greatest common divisor of a and b
 */
size_t gcdInternal(size_t a, size_t b)
{
    while(b!=0)
    {
        size_t temp = b;
        b = (a%b);
        a = temp;
    }
    return a;
}

/*!
 * \brief Finds the greatest common divisor of two integers using the euclidean algorithm by ensuring that the arguments are passed in inverse value order to gcdInternal
 * \param a The first integer input
 * \param b The second integer input
 * \return The greatest common divisor of a and b
 */
size_t greatestCommonDivisor(size_t a, size_t b)
{
    if(a>b){return Detail::gcdInternal(a,b);}
    else if(b>a){return Detail::gcdInternal(b,a);}
    else{return a;}
}

/*!
 * \brief Finds the least common multiple of two integers (using gcd)
 * \param a The first integer input
 * \param b The second integer input
 * \return The least common multiple of a and b
 */
size_t leastCommonMultiple(size_t a, size_t b)
{
    return ((a/greatestCommonDivisor(a,b))*b);
}

}
/*!
 * @brief Takes a size in bytes to allocate, increases it to be the nearest multiple of AlignmentLength then allocates it
 * @tparam ParamType The pointer type that needs to be returned
 * @tparam AlignmentLength The integer to align the addresses to, defaults to 64 since that is sufficient for cache lines and up to AVX-512 instructions
 * @param numCells The minimum number of ParamType cells to allocate
 * @return the pointer to the allocated memory
 */
template<class ParamType, int AlignmentLength=64>
ParamType* autoAlignedAlloc(size_t numCells)
{
    size_t arrayBlockSize = (Detail::leastCommonMultiple(AlignmentLength, sizeof(ParamType))/sizeof(ParamType));
    size_t arrayBlockCount = (numCells/arrayBlockSize);
    if((arrayBlockCount*arrayBlockSize) != numCells){++arrayBlockCount;}
    size_t allocSize = (arrayBlockCount*arrayBlockSize*sizeof(ParamType));
    //for some reason OSX's clang++ does not support the C11 standard aligned_alloc... wtf
#ifdef OSX_IS_ANNOYING
    ParamType* retVal;
    posix_memalign(reinterpret_cast<void**>(&retVal), AlignmentLength, allocSize);
    return retVal;
#else
    return reinterpret_cast<ParamType*>(aligned_alloc(AlignmentLength, allocSize));
#endif
}

/*!
 * @brief Takes a pointer that was generated by autoAlignedAlloc and frees it in the appropriate way
 * @param ptr The pointer to the memory segment to be freed
 */
template<class ParamType>
void delAAA(ParamType* ptr)
{
    free(ptr);
}

}
}
#endif  //MCMCPP_UTILITY_MISC_H
